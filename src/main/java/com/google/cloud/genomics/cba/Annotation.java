package com.google.cloud.genomics.cba;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import com.google.api.client.http.HttpResponse;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import javafx.util.Pair;


/**
 * <h1>Annotation APIs</h1> This class contains generic annotation APIs. It prepares and maps
 * Annotation fields to the corresponding fields in the Google Genomics annotation APIs. For more 
 * information, please refer to https://cloud.google.com/genomics/reference/rest/ 
 *
 * @param TOKEN
 *            A piece of data generated by the server which identifies a
 *            user.
 * @param referenceSetId
 *            The ID of the reference set that defines the coordinate space for this set's annotations.
 * @param annotationReferenceName
 * 				The display name corresponding to the reference specified by referenceId, for example chr1, 1, or chrX.
 * @param annotationStart
 * 				The start position of the range on the reference, 0-based inclusive.
 * @param annotationEnd
 * 				The end position of the range on the reference, 0-based exclusive.
 * @param annotationInfo
 * 				A map of additional read alignment information. This must be of the form map<string, string[]>
 *  			(string key mapping to a list of string values).	
 *  			An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
 * @param annotationName
 * 				The display name of this annotation.
 * @param annotationReferenceId
 * 				The ID of the Google Genomics reference associated with this range.
 * @param annotationReverseStrand
 * 				Whether this range refers to the reverse strand, as opposed to the forward strand. Note that regardless of this field, 
 * 				the start/end position of the range always refer to the forward strand.
 * @param annotationTranscript
 * 				A transcript value represents the assertion that a particular region of the reference genome may be transcribed as RNA. 
 * 				An alternative splicing pattern would be represented as a separate transcript object. 
 * 				This field is only set for annotations of type TRANSCRIPT.
 * @param annotationVariant
 * 				A variant annotation, which describes the effect of a variant on the genome, 
 * 				the coding sequence, and/or higher level consequences at the organism level e.g. 
 * 				pathogenicity. This field is only set for annotations of type VARIANT.
 *            
 * @version 1.0
 * @since 2016-07-17
 */

public class Annotation {

	/*REST API - Authentication Token*/
	private String TOKEN;

	/*Annotation Fields*/
	private String annotationSetId;
	private String annotationReferenceName;
	private long annotationStart;
	private long annotationEnd;
	private JsonObject annotationInfo;
	private String annotationName;
	private String annotationReferenceId;
	private boolean annotationReverseStrand;
	private JsonObject annotationTranscript;
	private JsonObject annotationVariant;
	
	/* HACK - Testing - needs updates */
	static String getIdFromJSON(ArrayList<String> output) {

		if (output == null)
			System.err.print("httpRequest failed!");
		else if (output.isEmpty())
			System.err.print("httpRequest failed!");

		for (String line : output) {
			if (line.contains("id")) { 
				String id = line.split(" ")[3].split("\"")[1];
				return id;
			}
		}

		StartAnnotationEngine.LOG.warning("httpRequest failed!");
		System.exit(0);
		return null;
	}

	   /**
	   * This method creates a JSON object for a set of <key, value> pairs, and sets annotationInfo. 
	   * @param mapInfo A HashMap that contains a set of <key, value> pairs. 
	   */
	
	public void createInfoJSON(HashMap<String, String> mapInfo){

		JsonObject info = new JsonObject();
		if (mapInfo == null) {
			StartAnnotationEngine.LOG.warning("Dataset for creating a map of additional read alignment information is empty!");
			System.exit(0);
		}else if (mapInfo.isEmpty()){
			StartAnnotationEngine.LOG.warning("Dataset for creating a map of additional read alignment information is empty!");
			System.exit(0);	
		}

		for (String key : mapInfo.keySet()) {
			JsonArray tempJSONArray = new JsonArray();
			tempJSONArray.add(mapInfo.get(key));
			info.add(key, tempJSONArray);
		}
		
		this.setAnnotationInfo(info);

	}

	

	   /**
	   * This method is used to create one or more new annotations automatically. 
	   * @param TOKEN A piece of data generated by the server which identifies a user.
	   * @param ANNs_JSON Contains String version of JSON of all annotations 
	   */
	
	static void batchCreateAnnotation(String TOKEN, String ANNs_JSON) {

		// String CURL = "curl -v -X POST -H \"Authorization: Bearer " + TOKEN +
		// "\"";
		// String JSON = "-d '" + ANNs_JSON + "'";
		// String HTTP_REQ = "--header \"Content-Type: application/json\"
		// https://genomics.googleapis.com/v1/annotations:batchCreate";

		// ArrayList<String> output = CurlHttpRequests.execution(CURL + " " +
		// JSON + " " + HTTP_REQ, ".");

		String PostUrl = "https://genomics.googleapis.com/v1/annotations:batchCreate";
		GoogleREST GAPI = new GoogleREST();
		GAPI.run(TOKEN, ANNs_JSON, PostUrl);

		if (null == GAPI.getResponse()) {
			StartAnnotationEngine.LOG.warning("\n\n\t\tcreateAnnotation Batch FAILED!");
			System.exit(0);
		}

	}


	   /**
	   * This method is used to creates one annotation automatically. 
	   */
	
	public void submitAnnotation() {

		if (getAnnotationSetId() != null && (getAnnotationReferenceId() != null || getAnnotationReferenceName() != null)) {

			// String CURL = "curl -v -X POST -H \"Authorization: Bearer " +
			// TOKEN + "\"";

			JsonObject annotation = new JsonObject();
			annotation.addProperty("annotationSetId", getAnnotationSetId());

			annotation.addProperty("start", getAnnotationStart());
			annotation.addProperty("end", getAnnotationEnd());

			if (getAnnotationVariant() != null)
				annotation.add("variant", getAnnotationVariant());

			if (getAnnotationInfo() != null)
				annotation.add("info", getAnnotationInfo());

			if (getAnnotationTranscript() != null)
				annotation.add("transcript", getAnnotationTranscript());

			if (isAnnotationReverseStrand())
				annotation.addProperty("reverseStrand", isAnnotationReverseStrand());

			if (getAnnotationReferenceName()!= null)
				if (!getAnnotationReferenceName().isEmpty())
					annotation.addProperty("referenceName", getAnnotationReferenceName());

			if(getAnnotationReferenceId() != null)
				if (!getAnnotationReferenceId().isEmpty())
					annotation.addProperty("referenceId", getAnnotationReferenceId());

			if (getAnnotationName() != null){
				annotation.addProperty("name", getAnnotationName());
			}
			Gson gson = new Gson();

			/* CURL */
			// String JSON = "-d '" + gson.toJson(annotation).toString() + "'";
			// String HTTP_REQ = "--header \"Content-Type: application/json\"
			// https://genomics.googleapis.com/v1/annotations";
			// System.out.println(CURL + " " + JSON + " " + HTTP_REQ);
			// ArrayList<String> output = CurlHttpRequests.execution(CURL + " "
			// + JSON + " " + HTTP_REQ, ".");
			//System.out.println(gson.toJson(annotation).toString());
			String PostUrl = "https://genomics.googleapis.com/v1/annotations";
			GoogleREST GAPI = new GoogleREST();
			GAPI.run(getTOKEN(), gson.toJson(annotation).toString(), PostUrl);
				
			if (null == GAPI.getResponse()) {
				StartAnnotationEngine.LOG.warning("createAnnotation FAILED!");
				System.exit(0);
			}
			else{
				StartAnnotationEngine.LOG.warning("createAnnotation SUCCESS!");

			}

		} else
			StartAnnotationEngine.LOG.warning(
					"The following fields are required to create an annotation: 1) annotationSetId and 2) referenceName or referenceId");

	}
	
	   /**
	   * This method is used to creates the JSON version of an annotation atomically.
	   * The batch creation method uses this method to create Annotation's JSON object, and 
	   * add JsonObjects to a JsonArray, and submits a batch of annotations.   
	   * @return JSON Object of Annotation 
	   */
	
	public JsonObject createAnnotationJSON(){
		
		JsonObject annotationJson = new JsonObject();

		if (this.getAnnotationSetId() != null && (this.getAnnotationReferenceId() != null || 
				this.getAnnotationReferenceName() != null)) {

			annotationJson.addProperty("annotationSetId", annotationSetId);

			annotationJson.addProperty("start", this.getAnnotationStart());
			annotationJson.addProperty("end", this.getAnnotationEnd());

			if (this.getAnnotationInfo() != null)
				annotationJson.add("info", this.getAnnotationInfo());

			if (this.isAnnotationReverseStrand())
				annotationJson.addProperty("reverseStrand", isAnnotationReverseStrand());

			// Either referenceName or referenceId
			if (!this.getAnnotationReferenceName().isEmpty())
				annotationJson.addProperty("referenceName", this.getAnnotationReferenceName());

			else
				annotationJson.addProperty("referenceId", this.getAnnotationReferenceId());
		} else{
			StartAnnotationEngine.LOG.warning(
					"The following fields are required to create an annotation: 1) annotationSetId and 2) referenceName or referenceId");
			System.exit(0);
		}
		
		return annotationJson;
	}
	
	   /**
	   * This method is used to retrieve annotations based on Chromosome, start, and end. 
	   */
	
	public void getAnnotation() {

		if ((this.getAnnotationReferenceName() != null && !this.getAnnotationReferenceName().isEmpty()) 
			&& (this.getAnnotationSetId()!= null && !this.getAnnotationSetId().isEmpty())){
						
			
			String SEARCH= "{ \"annotationSetIds\": [  \"" + this.getAnnotationSetId() 
			+ "\" ], \"start\": \"" + this.getAnnotationStart() 
			+"\", \"end\": \"" + this.getAnnotationEnd() 
			+"\", \"referenceName\": \"" + this.getAnnotationReferenceName() + "\"}";
			
			String PostUrl = "https://genomics.googleapis.com/v1/annotations/search";
			GoogleREST GAPI = new GoogleREST();
			
			GAPI.run(getTOKEN(), SEARCH, PostUrl);
		    JsonElement jelement = new JsonParser().parse(GAPI.getOutput());
		    
		    JsonObject subMenuArray = jelement.getAsJsonObject();
		    for(int i=0; i<subMenuArray.getAsJsonArray("annotations").size(); i++){
		    	  StartAnnotationEngine.LOG.warning("E" + Integer.toString(i) + ": " +subMenuArray.getAsJsonArray("annotations").get(i).getAsJsonObject());
		    }
		
		}else
		{
			StartAnnotationEngine.LOG.warning("getAnnotation: either ReferenceName or AnnotationSetId is missing!");
		}
		

	}

	public String getAnnotationSetId() {
		return annotationSetId;
	}

	public void setAnnotationSetId(String annotationSetId) {
		this.annotationSetId = annotationSetId;
	}

	public String getAnnotationReferenceName() {
		return annotationReferenceName;
	}

	public void setAnnotationReferenceName(String annotationReferenceName) {
		this.annotationReferenceName = annotationReferenceName;
	}

	public long getAnnotationStart() {
		return annotationStart;
	}

	public void setAnnotationStart(long annotationStart) {
		this.annotationStart = annotationStart;
	}

	public long getAnnotationEnd() {
		return annotationEnd;
	}

	public void setAnnotationEnd(long annotationEnd) {
		this.annotationEnd = annotationEnd;
	}

	public JsonObject getAnnotationInfo() {
		return annotationInfo;
	}

	public void setAnnotationInfo(JsonObject annotationInfo) {
		this.annotationInfo = annotationInfo;
	}

	public String getAnnotationName() {
		return annotationName;
	}

	public void setAnnotationName(String annotationName) {
		this.annotationName = annotationName;
	}

	public String getAnnotationReferenceId() {
		return annotationReferenceId;
	}

	public void setAnnotationReferenceId(String annotationReferenceId) {
		this.annotationReferenceId = annotationReferenceId;
	}

	public boolean isAnnotationReverseStrand() {
		return annotationReverseStrand;
	}

	public void setAnnotationReverseStrand(boolean annotationReverseStrand) {
		this.annotationReverseStrand = annotationReverseStrand;
	}

	public JsonObject getAnnotationTranscript() {
		return annotationTranscript;
	}

	public void setAnnotationTranscript(JsonObject annotationTranscript) {
		this.annotationTranscript = annotationTranscript;
	}

	public JsonObject getAnnotationVariant() {
		return annotationVariant;
	}

	public void setAnnotationVariant(JsonObject annotationVariant) {
		this.annotationVariant = annotationVariant;
	}


	public String getTOKEN() {
		return TOKEN;
	}

	public void setTOKEN(String token) {
		TOKEN = token;
	}

}
