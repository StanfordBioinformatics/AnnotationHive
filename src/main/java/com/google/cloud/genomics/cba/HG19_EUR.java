package com.google.cloud.genomics.cba;

import java.util.ArrayList;
import java.util.HashMap;

import com.google.gson.JsonObject;

import javafx.util.Pair;


/**
* <h1>HG19_EUR Annotation APIs</h1>
* This class created for HG19_EUR annotation
* It converts HG19_EUR fields to the fields 
* in Google Genomics annotation APIs   
*
* @version 1.0
* @since   2016-07-17
*/

public class HG19_EUR {

	   /**
	   * This method is used to initialize annotation objects. It also maps annotation field values 
	   * to the corresponding variables in the annotation object  
   	   * @param annotationSetId The ID of the reference set that defines the coordinate space for this set's annotations.
	   * @param words Contains words/fields making a line of annotation input file 
	   * @return Annotation
	   */
	

	public static Annotation initAnnotation(String annotationSetId, String[] words){
		
		Annotation newAnnotation = new Annotation(); 
		
		newAnnotation.setAnnotationSetId(annotationSetId);
		/* The annotation set to which this annotation belongs.*/
		
		newAnnotation.setAnnotationReferenceName(words[0]);
		/*
		 * The display name corresponding to the reference specified by
		 * referenceId, for example chr1, 1, or chrX.
		 * 
		 */
		
		newAnnotation.setAnnotationReferenceId(null);
		/*
		* For dbSNP case, we only use refernceName
		* The ID of the Google Genomics reference associated with this range.
		* 
		*/

		long position = Long.parseLong(words[1]);
		newAnnotation.setAnnotationStart(position - 1);
		/*
		 * The start position of the range on the reference, 0-based inclusive.
		 * 
		 */
		
		newAnnotation.setAnnotationEnd(position);
		/*
		 * The end position of the range on the reference, 0-based exclusive.
		 * 
		 */

		newAnnotation.setAnnotationName(null);
		/*
		 * The display name of this annotation.
		 * 
		 */
		newAnnotation.setAnnotationReverseStrand(false); // double check
		/*
		 * Whether this range refers to the reverse strand, as opposed to the
		 * forward strand. Note that regardless of this field, the start/end
		 * position of the range always refer to the forward strand.
		 */

		newAnnotation.setAnnotationTranscript(null);
		/*
		 * A transcript value represents the assertion that a particular region
		 * of the reference genome may be transcribed as RNA. An alternative
		 * splicing pattern would be represented as a separate transcript
		 * object. This field is only set for annotations of type TRANSCRIPT.
		 */

		newAnnotation.setAnnotationVariant(null);
		/*
		 * A variant annotation, which describes the effect of a variant on the
		 * genome, the coding sequence, and/or higher level consequences at the
		 * organism level e.g. pathogenicity. This field is only set for
		 * annotations of type VARIANT.
		 *
		 */

		HashMap<String, String> mapInfo = new HashMap <String, String>();
		mapInfo.put("ref", words[2]); // .add(new Pair<String, String>("ref", words[2]));
		mapInfo.put("alternateBases", words[3]); //infoList.add(new Pair<String, String>("alternateBases", words[3]));
		mapInfo.put("Allele_frequency", words[4]);  // infoList.add(new Pair<String, String>("Allele_frequency", words[4]));
		mapInfo.put("dbSNPId", words[5]);  //infoList.add(new Pair<String, String>("dbSNPId", words[5]));
		/*
		 * A map of additional read alignment information. This must be of the
		 * form map<string, string[]> (string key mapping to a list of string
		 * values). An object containing a list of "key": value pairs. Example:
		 * { "name": "wrench", "mass": "1.3kg", "count": "3" }.
		 * 
		 */

		
		newAnnotation.createInfoJSON(mapInfo);
				
		
	return newAnnotation;
		
	}
	

	   /**
	   * This method is used to create and add an annotation. 
	   * @param TOKEN A piece of data generated by the server which identifies a user.
   	   * @param annotationSetId The ID of the reference set that defines the coordinate space for this set's annotations.
	   * @param words Contains words/fields coming form a line of the input annotation file 
	   */
	
	public static void createdbSNPAnnotation(String TOKEN, String annotationSetId, String[] words) {//, int indexName) {
		
		try{
			Annotation newAnnotation = new Annotation();
			newAnnotation = initAnnotation(annotationSetId, words);
			//newAnnotation.setAnnotationName(Integer.toString(indexName));
			newAnnotation.setTOKEN(TOKEN);
			newAnnotation.submitAnnotation();
		}catch(Exception e){
			System.err.println("createdbSNPAnnotation: " + e.getMessage());
		}

	}
	
	public static void getAnnotation(String TOKEN, String annotationSetId, String[] words) {
	
			try{
				Annotation newAnnotation = new Annotation();
				newAnnotation = initAnnotation(annotationSetId, words);
				//newAnnotation.setAnnotationName(Integer.toString(indexName));
				newAnnotation.setTOKEN(TOKEN);
				newAnnotation.getAnnotation();
				
			}
			catch(Exception e){
				System.err.println("getAnnotationSNPAnnotation: " + e.getMessage());
			}
	
	}
	
	
	
	
	
	   /**
	   * This method is used to generate the JSON format for an annotation. 
   	   * @param annotationSetId The ID of the reference set that defines the coordinate space for this set's annotations.
	   * @param words Contains words/fields making a line of annotation input file 
	   * @return JsonObject
	   */

	static JsonObject createAnnotationJSON(String annotationSetId, String[] words) {

		Annotation newAnnotation= null;
		try{
			newAnnotation = initAnnotation(annotationSetId, words);
			newAnnotation.submitAnnotation();
		}catch(Exception e){
			System.err.println("createAnnotationJSON " + e.getMessage());
		}

		if (newAnnotation != null)
			return newAnnotation.createAnnotationJSON();
		else
			return null;
	}
}
